<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Gaslit by a computer</title><link>/posts/</link><description>Recent content in Posts on Gaslit by a computer</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Coding tips</title><link>/coding-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/coding-tips/</guid><description>A note to myself about things I’ve learned over the years.
Don’t write “programs” – treat all code as an API. Sketch out an interface, then write the tests, then write the code. It’s ok to hack something together, but it still needs to work. You should fix it later. Wrap dependencies on complex systems into facades so that your code interacts through that facade. New tools really do tend to be better.</description></item><item><title>Figuring out all of the web stuff</title><link>/web-stuff/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/web-stuff/</guid><description>This is a stub.
I had a few jobs doing web development circa 12–15 years ago. HTML 4, CSS 2, pre‐ECMAScript 4 Javascript, and either PHP, Python, or ASP. These languages – especially Javascript, PHP, and ASP – were terrible. On the side, I tried out Java EE tools like Spring and gave Django a try. MVC was the standard practice, and Ajax was used where needed.
It was all terrible, but straightforward.</description></item><item><title>Good streaming parser design</title><link>/software-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/software-testing/</guid><description>Your parser doesn’t need to do any IO.
This is a stub.
In 2015, I wrote parsers for the genomics formats VCF and BED. I rewrote them a few months later and ended up with robust parsers for some 1990s formats in genomics-io. Also refer to the interface segregation principle.</description></item><item><title>Idiot’s guide to video encoding</title><link>/video-encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/video-encoding/</guid><description># Idiot’s guide to video encoding This is a stub.
Summary of video compression algorithms, including AVI, h.264, h.265, AV1, aVP9, and h.266. Bitrate and quality control. Hardware encoding pipelines, including Intel Quick Sync Video and Nvidia NVENC.</description></item><item><title>Misc topics</title><link>/misc-topics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/misc-topics/</guid><description> How to compile OpenCV when it won’t Least comprehensible code: abreak.c in htsbox Mole rats and thermoregulation Why Coca‐Cola removed cocaine Ropinirole and spontaneous gambling Are lungbusters effective?</description></item><item><title>New data science steps with Python</title><link>/data-science-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/data-science-setup/</guid><description>This is a draft.
Here are steps for a typical initial setup for data science in Python.
I’ve given similar instructions so much that I figured I’d write this down.
Install Oh My Zsh You’ll thank me later. (You’ll need ZSH installed for this to work.)
chsh -s /usr/bin/env zsh zsh sh -c &amp;#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;#34; Configure Git First, configure your username and email:
git config --global user.name &amp;#34;your_username&amp;#34; git config --global user.</description></item><item><title>Organization for research projects</title><link>/research-layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/research-layout/</guid><description>Designate data as either living or frozen.
This is a stub.
Frozen data should be timestamped and never changed. Living data can be updated but may be versioned. There are some great resources on good data organization, such as the OSF’s guide. Here, I’ll document the aspects of my protocols that work well (and leave out those that don’t).</description></item><item><title>Partitioning scheme</title><link>/partitioning-scheme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/partitioning-scheme/</guid><description># A partition scheme for a scientific workstation This is the rather strange partitioning scheme I used for my workstation, with justification. Ubuntu 20.10 on a 1 TB Samsung 980 Pro NVMe drive / PCI-E 4 drive:
mount point size (GB) filesystem (efi) 0.5 FAT32 (swap) 64 swap /tmp 96 btrfs / 160 btrfs /data 624 btrfs Here’s the rationale:</description></item><item><title>Setup for macOS for development</title><link>/macos-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/macos-setup/</guid><description>This is a draft.
There are other guides for setting up macOS for development. I found this guide useful for graduate students who are relatively new to programming.
Here’s what you’ll do:
Basic setup and installing tools Set up a good shell environment Fix security problems and add SSH and GPG keys Install final software Initial setup The obvious: Upgrade macOS, enable FileVault, and remove unneeded Login Items.</description></item><item><title>Setup for Windows for development</title><link>/windows-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/windows-setup/</guid><description>This is a draft.
A companion to a similar guide for macOS. There are similar guides across the web; this one contains some workarounds for various issues.
Contents:
Setup for hardware Features &amp;amp; configuration Fixing power settings issues Installing Chocolatey and useful apps Final security steps Setup for specific hardware This details setup for specific hardware that I have used on 6 PC/workstation builds.
Download at the NVIDIA driver page.</description></item><item><title>Software tests in science</title><link>/software-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/software-testing/</guid><description>This article is meant as an introduction to software testing for scientists. It will be updated over time.
Let’s get this out of the way – you must write tests. Tests are just as required in scientific software as in all other software. If you’re already convinced, skip this section.
“Researchers are spending more and more time writing computer software to model biological structures, simulate the early evolution of the Universe and analyse past climate data, among other topics.</description></item><item><title>The Python build landscape</title><link>/python-infrastructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/python-infrastructure/</guid><description>The landscape of Python build infrastructure is a mess. I made over 100 commits to get a sensible, elegant, and secure build. The result is a template project and tool called Tyrannosaurus.
Comparison to other languages In 2014 and 2015, I was mostly writing in Java and Scala. In Java, there are two widely used build tools: Maven and Gradle. They’re compatible and use the same repository. To build your code, run mvn package or gradle build.</description></item></channel></rss>